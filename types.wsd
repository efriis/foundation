@startuml

title "Foundation Types"

class Legend {
  - serialized_attribute: type
  ---
  - property: returned_type
  + method() -> returned_type
}

package serialization {
  class Serialized {
    - data: Dict[str, SerializedTypeOneOf]
    - root_id: str
    - version: List[int]
  }
  class SerializedTypeOneOf {
    - record_context: RecordContext
    - extracted_value: ExtractedValue
    - target_value: TargetValue
    - compared_value: ComparedValue
    - entity: Entity
    - extracted_value_collection: ExtractedValueCollection
    - target_value_collection: TargetValueCollection
    - compared_value_collection: ComparedValueCollection
    - entity_collection: EntityCollection
  }

  class RecordContextTransaction {
    - id: str
    - field_additions: RecordContext
    - previous_transaction: Optional[str]
    ---
    not applicable (serialization only)
    NOTE: This is a sketch for deduplication
  }
  Serialized -> SerializedTypeOneOf
  SerializedTypeOneOf -[hidden]right- RecordContextTransaction
}

Legend -[hidden]->serialization

package "targets (serializable)" as targets {
  class TargetValue {
    - id: str
    - field_name: str
    - bbox: Optional[BBox]
    - value: str
    ---
    - id: str
    - field_name: str
    - bbox: Optional[BBox]
    - value: str
  }
  note left of TargetValue {
    Open question: Is there a
    difference between "TargetValue"
    and an "AnnotatedValue", which is
    more tailored to training? What
    does "Target" imply that may or
    may not be desirable
  }
  class TargetValueCollection {
    - id: str
    - target_value_ids: List[str]
    ---
    - id: str
    + get_target_values() -> Iterable[TargetValue]
  }
}

package "comparison (serializable)" as comparison {
  class ComparedValueCollection {
    - id: str
    - compared_value_ids: List[str]
    ---
    - id: str
    + get_compared_values() -> Iterable[ComparedValue]
  }
  class ComparedValue {
    - id: str
    - target_id: str
    - extracted_id: str
    - score: float
    - message: Optional[str]
    ---
    - id: str
    - target: TargetValue
    - extracted: ExtractedValue
    - score: float
    - message: Optional[str]
  }
  note right of ComparedValue {
    Open question: should we
    be separating ComparedValue
    from ExtractedValue in
    order to keep comparison
    logic separate
  }
}

package "record (serializable)" as record {
  class RecordContext {
    - id: str
    - entity_ids: List[str]
    - collection_ids: List[str]
    - page_ids: List[str]
    - spatial_text_id: str
    ---
    - id: str
    + get_entities() -> Iterable[Entity]
    + get_collection_entities() -> Iterable[Entity]
    + get_pages() -> Iterable[Page]
    - spatial_text: SpatialText
  }
}

package extraction {
  class ExtractedValue {
    - id: str
    - field_name: str
    - type: str
    - serialized_value: bytes
    - entity_ids: Optional[List[str]]
    ---
    - id: str
    - field_name: str
    - type: str
    - serialized_value: bytes
    + get_entities() -> Optional[Iterable[Entity]]
  }
  class ExtractedValueCollection {
    - id: str
    - extracted_value_ids
  }
}

package entity {
  class Entity {
    - id: str
    - children_ids: List[str]
    - type_specific: EntityTypeOneOf
    ---
    - id: str
    - bbox: Optional[BBox]
    + get_children() -> Iterable[Entity]
    + get_bboxes() -> Iterable[BBox]
    ... more from type_specific
  }

  class EntityCollection {
    - id: str
    - entity_ids: List[str]
  }

  Entity <- EntityCollection

  class EntityTypeOneOf {
    - word: Word
    - filler_string: FillerString
    - sub_word: SubWord
    - page: Page
    - text: Text
  }

  Entity -> EntityTypeOneOf

  class Word {
    - bbox: BBox
    - text: str
    ---
    - text: str
    + __getitem__(slice) -> SubWord
  }
  class FillerString {
    - text: str
    ---
    - text: str
  }
  class SubWord {
    - word_id: str
    - start_index: int
    - end_index: int
    ---
    - text: str
    + __getitem__(slice) -> SubWord
  }
  class Page {
    - bbox: BBox
    - image_path: str
    ---
    - image_path: str
  }
  class Text {
    - word_ids: List[str] # can be subwords
    - type_specific: Optional[TextTypeOneOf]
    ---
    - text: str
    + __getitem__(slice) -> Text
  }
  class TextTypeOneOf {
    - date: Date
    - currency_amount: CurrencyAmount
    - person_name: PersonName
    - address: Address
  }
  Text -> TextTypeOneOf
  EntityTypeOneOf --> Word
  EntityTypeOneOf --> FillerString
  EntityTypeOneOf --> SubWord
  EntityTypeOneOf --> Page
  EntityTypeOneOf --> Text

  class Date {
    - year: int
    - month: int
    - day: int
    - likeness_score: float
    ---
    - year: int
    - month: int
    - day: int
    - likeness_score: float
  }
  class CurrencyAmount {
    - currency: str
    - amount: float
    - likeness_score: float
    ---
    - currency: str
    - amount: float
    - likeness_score: float
  }
  class PersonName {
    - likeness_score: float
    ---
    - likeness_score: float
  }
  class Address {
    - likeness_score: float
    ---
    - likeness_score: float
  }
  TextTypeOneOf --> Date
  TextTypeOneOf --> CurrencyAmount
  TextTypeOneOf --> PersonName
  TextTypeOneOf --> Address
}

package geometry {
  class Interval {
    a: float
    b: float
  }
  class Point {
    x: float
    y: float
  }
  class Rectangle {
    ix: Interval
    iy: Interval
  }
  class BBox {
    - page_index: int
    - rectangle: Rectangle
  }
  BBox -> Rectangle
  Rectangle -> Interval
}


ComparedValue --> TargetValue

Entity --> BBox
ExtractedValue --> Entity
ComparedValue --> ExtractedValue

RecordContext --> ExtractedValue
RecordContext --> Entity

Serialized -[hidden]-> RecordContext
Serialized -[hidden]-> ComparedValue

@enduml